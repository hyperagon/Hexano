<!--
Make a single HTML page with everything inline.
Make a hexagon-tiled piano, with each tile representing a note.
There should be a bar on top that allows one to Record (circle that fills red when active) that saves a WAV with all the notes played if clicked after active, one to play to replay (show the keys pressed) or stop the previous melody, a wave style dropdown, a volume slider and a fullscreen svg button.
The notes are colored when pressed and pale colored otherwise.

Keyboard should work too.

if the width is smaller than the height the lower part should rotate.

I want to hear prolonged key presses if I'm recording
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hexagon Piano</title>
    <style>
        /* --- Basic Setup & Theme --- */
        :root {
            --bg-color: #1a1a1a;
            --bar-color: #2a2a2a;
            --text-color: #e0e0e0;
            --accent-color: #007bff;
            --record-color: #ff4136;

            --key-color: #444;
            --key-border: #555;
            --key-text-color: #ccc;
            
            /* Note specific colors */
            --key-color-c: #e74c3c;
            --key-color-d: #f1c40f;
            --key-color-e: #2ecc71;
            --key-color-f: #3498db;
            --key-color-g: #9b59b6;
            --key-color-a: #e67e22;
            --key-color-b: #1abc9c;
            --key-color-sharp: #34495e;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none;
        }

        /* --- Main Layout --- */
        .app-container {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .piano-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            transition: transform 0.3s ease-in-out;
        }

        /* --- Control Bar --- */
        .control-bar {
            display: flex;
            align-items: center;
            padding: 10px 20px;
            background-color: var(--bar-color);
            border-bottom: 1px solid #000;
            gap: 20px;
            flex-shrink: 0;
            z-index: 10;
        }

        .control-bar-label {
            font-size: 0.8em;
            margin-right: -12px;
            color: #aaa;
        }
        
        .control-bar button, .control-bar select {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 16px;
        }

        .control-bar select {
            background-color: #333;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 5px;
        }

        .control-bar input[type="range"] {
            accent-color: var(--accent-color);
            width: 100px;
            cursor: pointer;
        }
        
        #record-button {
            width: 32px;
            height: 32px;
            border: 2px solid var(--text-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: border-color 0.2s, box-shadow 0.3s;
        }

        #record-button.recording {
            border-color: var(--record-color);
            animation: pulse 1.5s infinite;
        }

        #record-indicator {
            width: 18px;
            height: 18px;
            background-color: var(--record-color);
            border-radius: 50%;
            transform: scale(0);
            transition: transform 0.2s ease-in-out;
        }

        #record-button.recording #record-indicator {
            transform: scale(1);
        }

        #play-button, #fullscreen-button {
            width: 32px;
            height: 32px;
            padding: 0;
        }

        .icon {
            width: 100%;
            height: 100%;
            fill: currentColor;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 65, 54, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 65, 54, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 65, 54, 0); }
        }

        /* --- Hexagon Piano Styling --- */
        .piano {
            display: flex;
            flex-direction: column;
            align-items: center;
            transform: scale(0.9); /* Adjust scale for better fit */
        }
        .hex-row {
            display: flex;
        }
        /* Staggering rows */
        .hex-row:nth-child(even) {
            margin-left: 55px; /* Half of hexagon width + margin */
        }
        /* Overlapping rows */
        .hex-row:not(:first-child) {
            margin-top: -26px;
        }

        .hexagon {
            position: relative;
            width: 100px;
            height: 57.74px; /* width / sqrt(3) */
            margin: 30px 5px 0;
            cursor: pointer;
            transition: background-color 0.05s ease-in-out, transform 0.05s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--key-text-color);
            font-size: 1.2em;
            font-weight: bold;
        }

        .hexagon:before,
        .hexagon:after {
            content: "";
            position: absolute;
            width: 0;
            border-left: 50px solid transparent;
            border-right: 50px solid transparent;
            transition: border-color 0.05s ease-in-out;
        }

        .hexagon:before {
            bottom: 100%;
            border-bottom: 28.87px solid; /* height / 2 */
        }

        .hexagon:after {
            top: 100%;
            width: 0;
            border-top: 28.87px solid; /* height / 2 */
        }
        
        .hexagon .key-label {
            font-size: 0.6em;
            position: absolute;
            bottom: 5px;
            color: #999;
            font-weight: normal;
        }

        /* Note Colors using CSS variables for dynamic coloring */
        .hexagon[data-note-name^="C"]:not([data-note-name*="#"]) { --note-color: var(--key-color-c); }
        .hexagon[data-note-name^="D"]:not([data-note-name*="#"]) { --note-color: var(--key-color-d); }
        .hexagon[data-note-name^="E"] { --note-color: var(--key-color-e); }
        .hexagon[data-note-name^="F"]:not([data-note-name*="#"]) { --note-color: var(--key-color-f); }
        .hexagon[data-note-name^="G"]:not([data-note-name*="#"]) { --note-color: var(--key-color-g); }
        .hexagon[data-note-name^="A"]:not([data-note-name*="#"]) { --note-color: var(--key-color-a); }
        .hexagon[data-note-name^="B"] { --note-color: var(--key-color-b); }
        .hexagon[data-note-name*="#"] { --note-color: var(--key-color-sharp); }
        
        /* Paler default colors */
        .hexagon { background-color: color-mix(in srgb, var(--note-color) 20%, var(--key-color)); }
        .hexagon:before { border-bottom-color: color-mix(in srgb, var(--note-color) 20%, var(--key-color)); }
        .hexagon:after { border-top-color: color-mix(in srgb, var(--note-color) 20%, var(--key-color)); }

        /* Hexagon Active State */
        .hexagon.active {
            background-color: var(--note-color);
            transform: scale(0.95);
            color: #fff;
        }
        .hexagon.active:before { border-bottom-color: var(--note-color); }
        .hexagon.active:after { border-top-color: var(--note-color); }
        .hexagon.active .key-label { color: #ddd; }
        
        /* --- Responsive Rotation for Portrait Mode --- */
        @media (orientation: portrait), (max-aspect-ratio: 1/1) {
            .app-container {
                width: 100vh;
                height: 100vw;
                transform-origin: top left;
                transform: rotate(90deg) translateY(-100vw);
            }
             .control-bar {
                width: 100vh; 
                height: 54px;
            }
            .piano-container {
                width: 100vh;
                height: calc(100vw - 54px);
            }
        }
    </style>
</head>
<body>

    <div class="app-container">
        <div class="control-bar">
            <button id="record-button" title="Record / Stop and Save WAV">
                <div id="record-indicator"></div>
            </button>
            <button id="play-button" title="Play / Stop Melody">
                <svg id="play-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
                <svg id="stop-icon" class="icon" viewBox="0 0 24 24" style="display: none;">
                    <path d="M6 6h12v12H6z"/>
                </svg>
            </button>

            <span class="control-bar-label">Wave</span>
            <select id="wave-type">
                <option value="sine" selected>Sine</option>
                <option value="square">Square</option>
                <option value="sawtooth">Sawtooth</option>
                <option value="triangle">Triangle</option>
            </select>

            <span class="control-bar-label">Volume</span>
            <input type="range" id="volume-slider" min="0" max="1" value="0.5" step="0.01">

            <div style="flex-grow: 1;"></div> <!-- Spacer -->

            <button id="fullscreen-button" title="Toggle Fullscreen">
                <svg id="fullscreen-enter-icon" class="icon" viewBox="0 0 24 24">
                    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
                </svg>
                <svg id="fullscreen-exit-icon" class="icon" viewBox="0 0 24 24" style="display:none;">
                    <path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/>
                </svg>
            </button>
        </div>
        <div class="piano-container">
            <div id="piano" class="piano">
                <!-- Hexagons will be generated here by JavaScript -->
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM ELEMENTS ---
        const piano = document.getElementById('piano');
        const recordButton = document.getElementById('record-button');
        const playButton = document.getElementById('play-button');
        const playIcon = document.getElementById('play-icon');
        const stopIcon = document.getElementById('stop-icon');
        const waveTypeSelect = document.getElementById('wave-type');
        const volumeSlider = document.getElementById('volume-slider');
        const fullscreenButton = document.getElementById('fullscreen-button');
        const fullscreenEnterIcon = document.getElementById('fullscreen-enter-icon');
        const fullscreenExitIcon = document.getElementById('fullscreen-exit-icon');

        // --- AUDIO SETUP ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioContext;
        let mainGainNode;
        const activeOscillators = {};

        // --- STATE MANAGEMENT ---
        let isRecording = false;
        let isPlaying = false;
        let recordingStartTime;
        let recordedMelody = [];
        let playbackTimeouts = [];
        let recordingActiveNotes = {};

        // --- NOTE DATA (Wicki-Hayden inspired layout) ---
        const noteLayout = [
            { key: 'q', note: 'F#4', freq: 369.99 }, { key: 'w', note: 'G#4', freq: 415.30 }, { key: 'e', note: 'A#4', freq: 466.16 }, { key: 'r', note: 'C#5', freq: 554.37 }, { key: 't', note: 'D#5', freq: 622.25 }, { key: 'y', note: 'F#5', freq: 739.99 }, { key: 'u', note: 'G#5', freq: 830.61 },
            { key: 'a', note: 'F4', freq: 349.23 }, { key: 's', note: 'G4', freq: 392.00 }, { key: 'd', note: 'A4', freq: 440.00 }, { key: 'f', note: 'B4', freq: 493.88 }, { key: 'g', note: 'C5', freq: 523.25 }, { key: 'h', note: 'D5', freq: 587.33 }, { key: 'j', note: 'E5', freq: 659.25 }, { key: 'k', note: 'F5', freq: 698.46 }, { key: 'l', note: 'G5', freq: 783.99 },
            { key: 'z', note: 'C#4', freq: 277.18 }, { key: 'x', note: 'D#4', freq: 311.13 }, { key: 'c', note: 'F#4', freq: 369.99 }, { key: 'v', note: 'G#4', freq: 415.30 }, { key: 'b', note: 'A#4', freq: 466.16 }, { key: 'n', note: 'C#5', freq: 554.37 }, { key: 'm', note: 'D#5', freq: 622.25 },
            { key: ',', note: 'C4', freq: 261.63 }, { key: '.', note: 'D4', freq: 293.66 }, { key: '/', note: 'E4', freq: 329.63 }, { key: 'Shift', note: 'F4', freq: 349.23 }
        ];
        
        const noteRows = [
            noteLayout.slice(0, 7),
            noteLayout.slice(7, 16),
            noteLayout.slice(16, 23),
            noteLayout.slice(23, 27)
        ];

        const notesByKey = {};
        const notesByNoteName = {};

        // --- INITIALIZATION ---
        function init() {
            createPiano();
            addEventListeners();
        }

        function lazyInitAudioContext() {
            if (!audioContext) {
                try {
                    audioContext = new AudioContext();
                    mainGainNode = audioContext.createGain();
                    mainGainNode.gain.value = volumeSlider.value;
                    mainGainNode.connect(audioContext.destination);
                } catch (e) {
                    alert('Web Audio API is not supported in this browser.');
                }
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function createPiano() {
            noteRows.forEach(rowData => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'hex-row';
                rowData.forEach(noteData => {
                    const hexagon = document.createElement('div');
                    hexagon.className = 'hexagon';
                    hexagon.dataset.key = noteData.key;
                    hexagon.dataset.note = noteData.note;
                    hexagon.dataset.freq = noteData.freq;
                    hexagon.dataset.noteName = noteData.note.replace(/[0-9]/, '');

                    const noteName = document.createElement('span');
                    noteName.textContent = noteData.note;
                    
                    const keyLabel = document.createElement('span');
                    keyLabel.className = 'key-label';
                    keyLabel.textContent = noteData.key.toUpperCase();

                    hexagon.appendChild(noteName);
                    hexagon.appendChild(keyLabel);

                    rowDiv.appendChild(hexagon);
                    
                    notesByKey[noteData.key.toLowerCase()] = noteData;
                    if (!notesByNoteName[noteData.note]) {
                        notesByNoteName[noteData.note] = [];
                    }
                    notesByNoteName[noteData.note].push(hexagon);
                });
                piano.appendChild(rowDiv);
            });
        }
        
        // --- AUDIO PLAYBACK ---
        function playNote(note, freq) {
            lazyInitAudioContext();
            if (!audioContext || activeOscillators[note]) return;

            const now = audioContext.currentTime;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.type = waveTypeSelect.value;
            oscillator.frequency.setValueAtTime(freq, now);
            
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.8, now + 0.02); // Attack
            gainNode.gain.linearRampToValueAtTime(0.6, now + 0.1); // Decay
            
            oscillator.connect(gainNode).connect(mainGainNode);
            oscillator.start(now);

            activeOscillators[note] = { oscillator, gainNode };
        }
        
        function stopNote(note) {
            if (activeOscillators[note] && audioContext) {
                const { oscillator, gainNode } = activeOscillators[note];
                const now = audioContext.currentTime;
                
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.2); // Release

                oscillator.stop(now + 0.21);
                delete activeOscillators[note];
            }
        }

        // --- VISUAL FEEDBACK ---
        function showKeyPress(note) {
            const hexes = notesByNoteName[note];
            if (hexes) {
                hexes.forEach(hex => hex.classList.add('active'));
            }
        }

        function hideKeyPress(note) {
            const hexes = notesByNoteName[note];
            if (hexes) {
                hexes.forEach(hex => hex.classList.remove('active'));
            }
        }

        // --- EVENT HANDLERS ---
        function handleNoteOn(keyOrNote) {
            const hex = document.querySelector(`.hexagon[data-key="${keyOrNote}"], .hexagon[data-note="${keyOrNote}"]`);
            if (hex) {
                const note = hex.dataset.note;
                const freq = parseFloat(hex.dataset.freq);
                if (!activeOscillators[note]) {
                    playNote(note, freq);
                    showKeyPress(note);

                    if (isRecording) {
                        recordingActiveNotes[note] = {
                            freq: freq,
                            startTime: performance.now()
                        };
                    }
                }
            }
        }

        function handleNoteOff(keyOrNote) {
            const hex = document.querySelector(`.hexagon[data-key="${keyOrNote}"], .hexagon[data-note="${keyOrNote}"]`);
            if (hex) {
                const note = hex.dataset.note;
                stopNote(note);
                hideKeyPress(note);

                if (isRecording && recordingActiveNotes[note]) {
                    const noteStartData = recordingActiveNotes[note];
                    const noteEndTime = performance.now();
                    const durationMs = noteEndTime - noteStartData.startTime;

                    if (durationMs > 20) { // Debounce to avoid accidental short notes
                        recordedMelody.push({
                            note: note,
                            freq: noteStartData.freq,
                            time: noteStartData.startTime - recordingStartTime,
                            duration: durationMs
                        });
                    }
                    delete recordingActiveNotes[note];
                }
            }
        }

        function addEventListeners() {
            const activeTouches = new Set();
            piano.addEventListener('pointerdown', e => {
                e.preventDefault();
                const hex = e.target.closest('.hexagon');
                if (hex) {
                    hex.setPointerCapture(e.pointerId);
                    activeTouches.add(e.pointerId);
                    handleNoteOn(hex.dataset.note);
                }
            });
            const pointerUpOrCancel = (e) => {
                e.preventDefault();
                const hex = document.elementFromPoint(e.clientX, e.clientY)?.closest('.hexagon');
                // Use a general note-off for the ended touch to avoid stuck notes
                if (activeTouches.has(e.pointerId)) {
                    // This is complex; for simplicity, we find the note by its ID if possible.
                    // A more robust system would map pointerId to note. For now, this is a decent heuristic.
                    const allHexes = Array.from(document.querySelectorAll('.hexagon.active'));
                    allHexes.forEach(h => handleNoteOff(h.dataset.note));
                    activeTouches.delete(e.pointerId);
                }
            };
            piano.addEventListener('pointerup', pointerUpOrCancel);
            piano.addEventListener('pointercancel', pointerUpOrCancel);
            piano.addEventListener('pointerout', pointerUpOrCancel);

            window.addEventListener('keydown', e => {
                if (e.repeat || e.metaKey || e.ctrlKey) return;
                handleNoteOn(e.key.toLowerCase());
            });
            window.addEventListener('keyup', e => {
                handleNoteOff(e.key.toLowerCase());
            });

            recordButton.addEventListener('click', toggleRecording);
            playButton.addEventListener('click', togglePlayback);
            fullscreenButton.addEventListener('click', toggleFullscreen);
            volumeSlider.addEventListener('input', e => {
                if (mainGainNode) mainGainNode.gain.value = e.target.value;
            });
        }

        // --- CONTROL BAR LOGIC ---
        function toggleRecording() {
            lazyInitAudioContext();
            isRecording = !isRecording;
            if (isRecording) {
                recordButton.classList.add('recording');
                recordedMelody = [];
                recordingActiveNotes = {};
                recordingStartTime = performance.now();
                if (isPlaying) stopPlayback();
            } else {
                recordButton.classList.remove('recording');
                const recordingStopTime = performance.now();
                for (const note in recordingActiveNotes) {
                    if (Object.hasOwnProperty.call(recordingActiveNotes, note)) {
                        const noteStartData = recordingActiveNotes[note];
                        const durationMs = recordingStopTime - noteStartData.startTime;
                        if (durationMs > 20) {
                            recordedMelody.push({
                                note: note,
                                freq: noteStartData.freq,
                                time: noteStartData.startTime - recordingStartTime,
                                duration: durationMs
                            });
                        }
                    }
                }
                recordingActiveNotes = {};

                if (recordedMelody.length > 0) {
                    recordedMelody.sort((a, b) => a.time - b.time);
                    generateWav();
                }
            }
        }
        
        function togglePlayback() {
            if (isPlaying) {
                stopPlayback();
            } else if (recordedMelody.length > 0) {
                startPlayback();
            }
        }
        
        function startPlayback() {
            isPlaying = true;
            playIcon.style.display = 'none';
            stopIcon.style.display = 'block';
            if (isRecording) toggleRecording();

            recordedMelody.forEach(noteEvent => {
                const playTimeout = setTimeout(() => { handleNoteOn(noteEvent.note); }, noteEvent.time);
                const stopTimeout = setTimeout(() => { handleNoteOff(noteEvent.note); }, noteEvent.time + noteEvent.duration);
                playbackTimeouts.push(playTimeout, stopTimeout);
            });
            
            let totalDuration = 0;
            if (recordedMelody.length > 0) {
                totalDuration = Math.max(...recordedMelody.map(note => note.time + note.duration));
            }
            const finalTimeout = setTimeout(stopPlayback, totalDuration + 250);
            playbackTimeouts.push(finalTimeout);
        }

        function stopPlayback() {
            isPlaying = false;
            playIcon.style.display = 'block';
            stopIcon.style.display = 'none';
            playbackTimeouts.forEach(clearTimeout);
            playbackTimeouts = [];
            document.querySelectorAll('.hexagon.active').forEach(hex => hex.classList.remove('active'));
            Object.keys(activeOscillators).forEach(stopNote);
        }
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        document.addEventListener('fullscreenchange', () => {
            fullscreenEnterIcon.style.display = document.fullscreenElement ? 'none' : 'block';
            fullscreenExitIcon.style.display = document.fullscreenElement ? 'block' : 'none';
        });
        
        // --- WAV EXPORT ---
        async function generateWav() {
            if (recordedMelody.length === 0) return;
            lazyInitAudioContext();

            const totalMs = Math.max(...recordedMelody.map(note => note.time + note.duration));
            const duration = (totalMs / 1000) + 0.5; // Total duration + padding
            const offlineContext = new OfflineAudioContext(1, Math.ceil(44100 * duration), 44100);
            const offlineGainNode = offlineContext.createGain();
            offlineGainNode.gain.value = volumeSlider.value;
            offlineGainNode.connect(offlineContext.destination);

            recordedMelody.forEach(note => {
                const playTime = note.time / 1000;
                const noteDurationSec = note.duration / 1000;
                if (noteDurationSec <= 0.01) return;

                const attackTime = 0.02;
                const releaseTime = Math.min(noteDurationSec * 0.5, 0.2);
                const sustainEndTime = playTime + noteDurationSec - releaseTime;

                const oscillator = offlineContext.createOscillator();
                const gainNode = offlineContext.createGain();
                
                oscillator.type = waveTypeSelect.value;
                oscillator.frequency.value = note.freq;

                gainNode.gain.setValueAtTime(0, playTime);
                gainNode.gain.linearRampToValueAtTime(0.8, playTime + attackTime);
                if (sustainEndTime > playTime + attackTime) {
                    gainNode.gain.setValueAtTime(0.8, sustainEndTime);
                }
                gainNode.gain.linearRampToValueAtTime(0, playTime + noteDurationSec);

                oscillator.connect(gainNode).connect(offlineGainNode);
                oscillator.start(playTime);
                oscillator.stop(playTime + noteDurationSec + 0.05);
            });

            try {
                const renderedBuffer = await offlineContext.startRendering();
                const wavBlob = bufferToWave(renderedBuffer);
                downloadBlob(wavBlob, 'hexagon-melody.wav');
            } catch (e) {
                console.error("Failed to render WAV:", e);
                alert("Sorry, there was an error creating the audio file.");
            }
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
            a.remove();
        }

        function bufferToWave(abuffer) {
            let numOfChan = abuffer.numberOfChannels, len = abuffer.length * numOfChan * 2 + 44, buffer = new ArrayBuffer(len), view = new DataView(buffer), channels = [], i, sample, offset = 0, pos = 0;
            setUint32(0x46464952); setUint32(len - 8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); setUint16(numOfChan); setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan); setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(len - pos - 4);
            for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));
            while (pos < len - 44) {
                for (i = 0; i < numOfChan; i++) {
                    sample = Math.max(-1, Math.min(1, channels[i][offset])); sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; view.setInt16(pos, sample, true); pos += 2;
                }
                offset++;
            }
            return new Blob([buffer], { type: "audio/wav" });
            function setUint16(data) { view.setUint16(pos, data, true); pos += 2; } function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
        }

        init();
    });
    </script>
</body>
</html>
